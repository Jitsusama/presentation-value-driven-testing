<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Value Driven Testing</title>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section id="title">
          <h1 class="r-fit-text">Value Driven Testing</h1>
          <h2 class="r-fit-text">The who, what, when, where & why of developer testing</h2>
          <dl class="center">
            <dt>Presenter</dt>
            <dd>Joel Gerber (<a href="mailto:joel.gerber@molex.com">joel.gerber@molex.com</a>)</dd>
          </dl>
        </section>
        <section id="goal">
          <section><h2 class="r-fit-text">Goal</h2></section>
          <section>
            <h3>To Answer</h3>
            <ul>
              <li class="fragment"><em>Why</em> should we bother writing tests?</li>
              <li class="fragment"><em>What</em> type of tests should be written?</li>
              <li class="fragment"><em>Who</em> should write tests?</li>
              <li class="fragment"><em>When</em> should these tests be developed?</li>
              <li class="fragment"><em>Where</em> should these tests live?</li>
            </ul>
            <aside class="notes">
              <p>It should be noted that this talk is focused on automated testing.</p>
            </aside>
          </section>
        </section>
        <section id="why">
          <section>
            <h2 class="r-fit-text">Why?</h2>
            <aside class="notes"><p>Why should we bother writing (automated) tests?</p></aside>
          </section>
          <section>
            <h3>To Verify</h3>
            <p>A must to ensure we are providing value, yet;</p>
            <ul>
              <li class="fragment">
                This often happens haphazardly and is performed inconsistently.
              </li>
              <li class="fragment">
                It is onerous to record the how or what of manual verifications.
              </li>
              <li class="fragment">It is difficult to verify whether any shortcuts were taken.</li>
            </ul>
            <aside class="notes">
              <p>
                Verification is the process of validating that your software does what it is
                required to do. Without verification, we lack confidence that we are able to deliver
                what our customer needs.
              </p>
              <p>
                When verification is done manually we risk not having the proper verification taking
                place, or having it not done correctly.
              </p>
              <p>With automated verification (testing):</p>
              <ul>
                <li>
                  A single test run will consistently perform all tests and can even automatically
                  trigger them happening on code changes/pushes.
                </li>
                <li>
                  The test runner can provide a record of the steps & verifications performed and
                  identify any failed verifications.
                </li>
                <li>The test runner will run verifications the same way every time.</li>
              </ul>
            </aside>
          </section>
          <section>
            <h3>To Protect</h3>
            <p>Tests can protect us from value loss by validating:</p>
            <ul>
              <li class="fragment">Previously delivered functionality still functions.</li>
              <li class="fragment">Previously fixed bugs have not been reintroduced.</li>
            </ul>
            <aside class="notes">
              <p>
                When software of value has been created, there is always the potential for that
                value to be lost as new functionality is added.
              </p>
              <p>
                You can have automated tests triggered on code pushes, or run them manually at any
                time to have quick feedback before value loss makes it to a customer.
              </p>
            </aside>
          </section>
          <section>
            <h3>To Document</h3>
            <p>Tests are living documentation:</p>
            <ul style="display: block">
              <li class="fragment">Functional tests document use cases.</li>
              <li class="fragment">Unit tests document design.</li>
              <li class="fragment">Gives examples of how to use your exposed APIs.</li>
            </ul>
            <aside class="notes">
              <p>Documentation is vital, but often does not track with new changes.</p>
              <p>
                When your tests serve as documentation, they are guaranteed to never go out of date!
              </p>
            </aside>
          </section>
          <section>
            <h3>To Design</h3>
            <p>Tests can provide timely feedback on your design:</p>
            <ul>
              <li class="fragment">Hard to write tests often indicate bad designs.</li>
              <li class="fragment">
                With TDD, you can get feedback about your design before you've sunk time into
                implementing it.
              </li>
              <li class="fragment">
                You can see the dependencies and data types of your design within the tests.
              </li>
            </ul>
            <aside class="notes">
              <p>Hard test design smells:</p>
              <ul>
                <li>Too many dependencies implies your code has too many responsibilities.</li>
                <li>
                  Too many tests for a particular API implies that it is probably doing too much.
                </li>
                <li>
                  If engaging your API feels weird, it might mean a name change is in order, or the
                  parameters should be extracted into their own type.
                </li>
              </ul>
            </aside>
          </section>
          <section>
            <h3>To Focus</h3>
            <p>Using tests to guide what you do can help focus work:</p>
            <ul>
              <li class="fragment">
                Starting with a functional test can let you know when core functionality is done.
              </li>
              <li class="fragment">
                You can stub out failing unit tests for the pieces of functionality that have to be
                written.
              </li>
              <li class="fragment">Failing tests can identify work left to be done.</li>
              <li class="fragment">
                Flesh out the unit test you want to work on first and then write just enough code to
                make it pass to reduce wasteful coding.
              </li>
            </ul>
            <aside class="notes">
              <p>
                Working on new functionality can get overwhelming when the functionality is complex.
                Using tests to guide what you do next can help tame the complexity beast.
              </p>
              <p>
                This helps to focus work on what is needed to meet the current needs instead of
                future possibilities.
              </p>
            </aside>
          </section>
        </section>
        <section id="what">
          <section>
            <h2 class="r-fit-text">What?</h2>
            <aside class="notes"><p>What type of tests should be written?</p></aside>
          </section>
          <section>
            <h3>Functional</h3>
            <p>These types of tests should:</p>
            <ul>
              <li class="fragment">Capture actual user requirements.</li>
              <li class="fragment">Be clean and readable.</li>
              <li class="fragment">Test the system/solution like a black box.</li>
              <li class="fragment">Exercise functionality as a user would engage it.</li>
            </ul>
            <aside class="notes">
              <p>
                Functional tests serve as a north star. When a functional (E2E/System/Solution) test
                passes, it identifies that a user requirement has been met.
              </p>
              <p>
                The quantity of functional tests should not exceed the amount of testing required to
                give confidence that the basic user's requirement have been met. Too many functional
                tests can cause automated test runs to take too long, slowing down the feedback
                cycle. Edge cases can be tackled in integrated or unit tests.
              </p>
              <p>
                These tests are quite valuable as living documentation, showing what functionality
                the solutions supports, and being executable you can always be confident that the
                delivered value is never lost during future changes.
              </p>
            </aside>
          </section>
          <section>
            <h3>Integrated</h3>
            <p>These types of tests should:</p>
            <ul>
              <li class="fragment">
                Capture happy paths and edge cases supporting a failing functional test.
              </li>
              <li class="fragment">Be clean and readable.</li>
              <li class="fragment">Test a component of a solution like a black box.</li>
              <li class="fragment">
                Exercise the component like a client of the component under test would engage it.
              </li>
            </ul>
            <aside class="notes">
              <p>
                Integrated tests are useful when testing components that make up a part of a
                solution. When an integrated test passes, it identifies that this component has
                satisfied a use case that contributes to a functional test.
              </p>
              <p>
                These help you focus when tackling an individual component, helping you to only work
                on a single code path at a time.
              </p>
              <p>
                These tests are quite valuable as living documentation, showing what use cases this
                component is meant to serve, and being executable you can always be confident that
                the delivered value is never lost during future changes.
              </p>
            </aside>
          </section>
          <section>
            <h3>Unit</h3>
            <p>These types of test should:</p>
            <ul>
              <li class="fragment">
                Capture happy paths and edge cases supporting a failing integration test.
              </li>
              <li class="fragment">Be clean and readable.</li>
              <li class="fragment">
                Test a single responsibility of a component like a black box.
              </li>
              <li class="fragment">
                Exercise the responsibility's public API like a client of this API under test would
                engage it.
              </li>
            </ul>
            <aside class="notes">
              <p>
                Unit tests are often confused with testing a single function/class/method in
                isolation. While they can be this, historically a unit was meant to reflect any
                grouping of code that provides value when being programmatically tested.
              </p>
              <p>
                These can help you focus on single responsibilities of a component, without having
                to focus on the entire problem that you are currently trying to solve.
              </p>
              <p>
                These tests are quite valuable as living documentation, showing the design of a
                single component responsibility, and how the API of that responsibility can be
                engaged.
              </p>
            </aside>
          </section>
        </section>
        <section id="who">
          <section>
            <h2 class="r-fit-text">Who?</h2>
            <aside class="notes">
              <p>Who should write these tests?</p>
              <p>Developers, Developers, Developers!</p>
            </aside>
          </section>
          <section>
            <h3>Quality Assurance</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
          <section>
            <h3>Integration</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
          <section>
            <h3>Component</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
        </section>
        <section id="when">
          <section>
            <h2 class="r-fit-text">When?</h2>
            <aside class="notes">When should these tests be developed?</aside>
          </section>
          <section>
            <h3>After</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
          <section>
            <h3>Before</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
          <section>
            <h3>Mixture</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
        </section>
        <section id="where">
          <section>
            <h2 class="r-fit-text">Where?</h2>
            <aside class="notes">Where should these tests live?</aside>
          </section>
          <section>
            <h3>Close to the Source</h3>
            <p></p>
            <ul></ul>
            <aside class="notes"><p></p></aside>
          </section>
        </section>
      </div>
    </div>
    <script type="module" src="reveal.js"></script>
  </body>
</html>
