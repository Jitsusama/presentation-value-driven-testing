<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Value Driven Testing</title>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section id="title">
          <h1 class="r-fit-text">Value Driven Testing</h1>
          <h2 class="r-fit-text">The who, what, when, where & why of developer testing</h2>
          <dl class="center">
            <dt>Presenter</dt>
            <dd>Joel Gerber (<a href="mailto:joel.gerber@molex.com">joel.gerber@molex.com</a>)</dd>
          </dl>
        </section>
        <section id="goal">
          <section><h2 class="r-fit-text">Goal</h2></section>
          <section>
            <h3>To Answer</h3>
            <ul>
              <li class="fragment"><em>Why</em> should we bother writing tests?</li>
              <li class="fragment"><em>What</em> types of tests should be written?</li>
              <li class="fragment"><em>Who</em> should write these tests?</li>
              <li class="fragment"><em>When</em> should these tests be developed?</li>
              <li class="fragment"><em>Where</em> should these tests live?</li>
            </ul>
          </section>
        </section>
        <section id="why">
          <section>
            <h2 class="r-fit-text">Why?</h2>
            <aside class="notes">
              <p>Why should we bother writing (automated) tests?</p>
              <p>
                <em>Poll:</em> Ask this as an open-ended question and try to get a few thoughts from
                the audience.
              </p>
            </aside>
          </section>
          <section>
            <h3>To Verify</h3>
            <p class="fragment">Verification is needed, yet;</p>
            <ul>
              <li class="fragment">It often happens haphazardly and inconsistently.</li>
              <li class="fragment">It is onerous to record the how or what of manual tests.</li>
              <li class="fragment">It is hard to know if any shortcuts were taken.</li>
            </ul>
            <aside class="notes">
              <p>
                <em>At Start:</em> Verification is the process of validating that your software does
                what it is required to do. Without this, we lack confidence that we have developed
                what our customer needs.
              </p>
              <p>
                <em>At End:</em> When verification is done manually we risk not having the proper
                verification taking place, or not having it done correctly.
              </p>
              <p>With automated verifications:</p>
              <ul>
                <li>
                  A single test run will consistently run all tests and can be triggered to happen
                  on code changes/pushes.
                </li>
                <li>
                  The test runner can provide a record of the steps taken, verifications performed
                  and identify any failed verifications.
                </li>
                <li>The test runner will run verifications the same way every time.</li>
              </ul>
            </aside>
          </section>
          <section>
            <h3>To Protect</h3>
            <p class="fragment">Tests can protect us from value loss by validating:</p>
            <ul>
              <li class="fragment">Previously delivered functionality still functions.</li>
              <li class="fragment">Previously fixed bugs have not been reintroduced.</li>
              <li class="fragment">
                A record of previously delivered functionality and bug fixes is never lost.
              </li>
            </ul>
            <aside class="notes">
              <p>
                <em>At Start:</em> When software of value has been created, there is always the
                potential for that value to be lost as new functionality is added.
              </p>
              <p>
                <em>At End:</em> With automated tests you are able to get a quick indication of
                value loss before it makes it to the customer.
              </p>
            </aside>
          </section>
          <section>
            <h3>To Document</h3>
            <p class="fragment">Tests are living documentation:</p>
            <ul style="display: block">
              <li class="fragment">Functional tests document use cases.</li>
              <li class="fragment">Unit tests document design.</li>
              <li class="fragment">
                Both function as living examples of how to interface with your APIs.
              </li>
            </ul>
            <aside class="notes">
              <p>
                <em>At Start:</em> Documentation is vital, but often does not track with new
                changes.
              </p>
              <p>
                <em>At End:</em> When your tests serve as documentation, they are guaranteed to
                never go out of date!
              </p>
            </aside>
          </section>
          <section>
            <h3>To Design</h3>
            <p class="fragment">Tests can provide timely feedback on your design:</p>
            <ul>
              <li class="fragment">Hard to write tests often indicate bad designs.</li>
              <li class="fragment">
                Can give feedback about your design before you've sunk too much time into it.
              </li>
              <li class="fragment">
                Help document your design and clearly identify its dependencies and data types.
              </li>
            </ul>
            <aside class="notes">
              <p>
                <em>At Start:</em> Software design is a skill that requires you to step back and
                think about the problem you're trying to solve and then plan out an evolvable
                structure that a solution can be built on.
              </p>
              <p><em>At End:</em> Some example design feedbacks (smells) tests can expose:</p>
              <ul>
                <li>Too many dependencies implies your code has too many responsibilities.</li>
                <li>
                  Too many tests for a particular API implies that it is probably doing too much.
                </li>
                <li>
                  If engaging your API feels weird, it might mean a name change is in order, or that
                  some parameters should be extracted into their own type.
                </li>
              </ul>
            </aside>
          </section>
          <section>
            <h3>To Focus</h3>
            <p class="fragment">How tests can guide you to more focused work:</p>
            <ul>
              <li class="fragment">
                Functional tests force you to think about the problem before solving it.
              </li>
              <li class="fragment">
                Unit tests help break down the problem into smaller parts that can be tackled one at
                a time.
              </li>
              <li class="fragment">
                Going from a functional test and then diving into supporting unit tests reduces
                wasteful coding.
              </li>
              <li class="fragment">Failing tests can identify what to work on next.</li>
            </ul>
            <aside class="notes">
              <p><em>At Start:</em></p>
              <p>
                Working on new functionality can get overwhelming when the functionality is complex.
                Using tests to guide what you do next can help tame the complexity beast.
              </p>
              <p>
                This helps to focus work on what is needed to meet current needs instead of future
                uncertainties.
              </p>
            </aside>
          </section>
        </section>
        <section>
          <q>We only see what we know.</q>
          <p style="font-size: 0.5em">&mdash; Goethe</p>
        </section>
        <section id="what">
          <section>
            <h2 class="r-fit-text">What?</h2>
            <aside class="notes">
              <p>What types of tests should be written?</p>
              <p>
                <em>Poll:</em> Ask this as an open-ended question and try to get a few thoughts from
                the audience.
              </p>
            </aside>
          </section>
          <section>
            <h3>Functional</h3>
            <p class="fragment">These types of tests should:</p>
            <ul>
              <li class="fragment">Capture actual user requirements.</li>
              <li class="fragment">Be clean and readable.</li>
              <li class="fragment">Test the system/solution like a black box.</li>
              <li class="fragment">Exercise functionality as a user would engage it.</li>
            </ul>
            <aside class="notes">
              <p><em>At Start:</em></p>
              <p>
                Functional tests serve as a north star. When a functional (E2E/System/Solution) test
                passes, it identifies that a user requirement has been met.
              </p>
              <p><em>At End:</em></p>
              <p>
                The quantity of functional tests should ~= just enough to give confidence that the
                basic user's requirement have been met. Too many functional tests can slow down test
                runs, thereby slowing down the feedback cycle. Edge cases can be tackled in
                integrated or unit tests.
              </p>
              <p>
                These tests are quite valuable as living documentation, showing what functionality
                the solutions supports, and being executable you can always be confident that the
                delivered value is never lost.
              </p>
            </aside>
          </section>
          <section>
            <h3>Integrated</h3>
            <p class="fragment">These types of tests should:</p>
            <ul>
              <li class="fragment">
                Capture happy paths and edge cases supporting a failing functional test.
              </li>
              <li class="fragment">Be clean and readable.</li>
              <li class="fragment">Test a component of a solution like a black box.</li>
              <li class="fragment">
                Exercise the component like a client of the component under test would engage it.
              </li>
            </ul>
            <aside class="notes">
              <p><em>At Start:</em></p>
              <p>
                Integrated tests are useful when testing components that make up a part of a
                solution. When an integrated test passes, it identifies that this component has
                satisfied a use case that contributes to a functional test.
              </p>
              <p><em>At End:</em></p>
              <p>
                These tests help you focus when tackling an individual component, directing you to
                only work on a single code path at a time.
              </p>
              <p>
                These tests are quite valuable as living documentation, showing what use cases this
                component is meant to serve, and being executable you can always be confident that
                the delivered value is never lost during future changes.
              </p>
            </aside>
          </section>
          <section>
            <h3>Unit</h3>
            <p class="fragment">These types of test should:</p>
            <ul>
              <li class="fragment">
                Capture happy paths and edge cases supporting a failing integration test.
              </li>
              <li class="fragment">Be clean and readable.</li>
              <li class="fragment">
                Test a single responsibility of a component like a black box.
              </li>
              <li class="fragment">
                Exercise the responsibility's public API like a client of this API under test would
                engage it.
              </li>
            </ul>
            <aside class="notes">
              <p><em>At Start:</em></p>
              <p>
                Unit tests are often confused with testing a single function/class/method in
                isolation. While they can be this, historically a unit was meant to reflect any
                grouping of code that provides value when being programmatically tested.
              </p>
              <p><em>At End:</em></p>
              <p>
                These tests can help you focus on single responsibilities of a component, without
                having to focus on the entire problem that you are currently trying to solve.
              </p>
              <p>
                These tests are quite valuable as living documentation, showing the design of a
                single component responsibility, and how the API of that responsibility can be
                engaged.
              </p>
            </aside>
          </section>
        </section>
        <section>
          <q>All code is guilty until proven innocent.</q>
          <p style="font-size: 0.5em">&mdash; Anonymous</p>
        </section>
        <section id="who">
          <section>
            <h2 class="r-fit-text">Who?</h2>
            <aside class="notes">
              <p>Who should write these tests?</p>
              <p>
                <em>Poll:</em> Ask this as an open-ended question and try to get a few thoughts from
                the audience.
              </p>
            </aside>
          </section>
          <section>
            <video
              title="Steve Balmer - Developers! Developers! Developers!"
              height="340"
              width="420"
              muted
              playsinline
              autoplay
              loop
              preload="auto"
              poster="https://thumbs.gfycat.com/ConfusedGracefulArgentinehornedfrog-mobile.jpg"
            >
              <source
                src="https://zippy.gfycat.com/ConfusedGracefulArgentinehornedfrog.mp4"
                type="video/mp4"
              />
            </video>
            <p style="font-size: small">
              <a
                href="https://gfycat.com/confusedgracefulargentinehornedfrog-steve-ballmer-developers"
                >via Gfycat</a
              >
            </p>
            <aside class="notes">
              <p>
                Steve Balmer in the memeified Microsoft developer's conference screaming:
                "Developers! Developers! Developers!"
              </p>
            </aside>
          </section>
          <section>
            <h3>Developers!</h3>
            <ul>
              <li class="fragment">Functional tests require knowledge of the problem domain.</li>
              <li class="fragment">Integration tests require knowledge of the component's role.</li>
              <li class="fragment">Unit tests require knowledge of the unit's responsibility.</li>
              <li class="fragment">Utilize QA, business analysts and SMEs for help!</li>
            </ul>
            <aside class="notes">
              <p>
                <em>At Start:</em> Developers write the solution and must acquire the problem domain
                knowledge necessary to solve it. Writing automated tests helps identify knowledge
                gaps before trying to implement it. It's not a waste of your time, instead it is a
                vital use of it!
              </p>
              <p><em>At End:</em> Reach out for help!</p>
              <ul>
                <li>
                  QA is trained to find edge cases. They are great at giving ideas about how you can
                  test from every angle.
                </li>
                <li>
                  Business analysts/product owners/the customer together should be able to provide
                  context about the problem which helps identify what should be tested.
                </li>
                <li>
                  SMEs in testing/technologies/the problem domain can help figure out how to set up
                  a test environment and how to engage complicated systems as part of your tests.
                </li>
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <q
            >The problem is not that testing is the bottleneck. The problem is that you donâ€™t know
            what's in the bottle. That's a problem that testing addresses.</q
          >
          <p style="font-size: 0.5em">&mdash; Michael Bolton</p>
        </section>
        <section id="when">
          <section>
            <h2 class="r-fit-text">When?</h2>
            <aside class="notes">
              <p>When should these tests be developed?</p>
              <p>
                <em>Poll:</em> Ask this as an open-ended question and try to get a few thoughts from
                the audience.
              </p>
            </aside>
          </section>
          <section>
            <h3>After</h3>
            <ul id="when-after-list">
              <li class="fragment">You start writing production code quicker.</li>
              <li class="fragment">It takes longer to finish the production code.</li>
              <li class="fragment">You get late feedback on your design.</li>
              <li class="fragment">The tests are harder to write.</li>
              <li class="fragment">Often doesn't happen.</li>
            </ul>
            <aside class="notes">
              <p>When you write tests after the production code is written:</p>
              <ul>
                <li>Because you don't have to think first, you can start writing code sooner.</li>
                <li>
                  But the finished code takes longer as you were not forced to think through the
                  problem before trying to solve it.
                </li>
                <li>
                  Since you don't get test feedback on your design early on, its often too late to
                  act on what it tells you as too much time has been sunk into it.
                </li>
                <li>
                  Since the code wasn't written with tests in mind, the tests are harder to write
                  and often require redesigns of your production code.
                </li>
                <li>
                  At the end of a development cycle, time crunches are real which cause left over
                  things to be dropped, such as tests.
                </li>
              </ul>
            </aside>
          </section>
          <section>
            <h3>Before</h3>
            <ul id="when-before-list">
              <li class="fragment">You start writing production code later.</li>
              <li class="fragment">It takes less time to finish the production code.</li>
              <li class="fragment">You get early feedback on your design.</li>
              <li class="fragment">The tests are easier to write.</li>
              <li class="fragment">You have the time to write them.</li>
            </ul>
            <aside class="notes">
              <p>When you write tests before the production code is written:</p>
              <ul>
                <li>
                  By being forced to think through the problem in order to write a test for it,
                  starting to write the solution gets delayed.
                </li>
                <li>
                  Since the problem has already been thought through, it takes less time to write
                  the final solution.
                </li>
                <li>
                  You can get feedback on the design before you implement it, so its really quick
                  and cheap to act on any feedback you get.
                </li>
                <li>
                  With the problem new and fresh on your mind, and without having production code
                  already written to constrain setting it up in the test, tests are quicker to
                  write.
                </li>
                <li>
                  With the tests happening first, and having the constraint that the solution cannot
                  be shipped without the code being written, you should always be able to have the
                  tests written.
                </li>
              </ul>
            </aside>
          </section>
          <section>
            <h3>Mixture</h3>
            <p>Reality is rarely so simple. For brownfield code:</p>
            <ol>
              <li class="fragment">Selectively write tests around existing code.</li>
              <li class="fragment">Safely improve the existing design.</li>
              <li class="fragment">Write tests for what is new.</li>
            </ol>
            <aside class="notes">
              <p>
                On a brownfield system you will often have a lot of untested code. There are
                strategies you can use to safely introduce changes:
              </p>
              <ul>
                <li>
                  Identify the area of the solution that will have to be touched to introduce
                  changes and write tests around its existing functionality.
                </li>
                <li>
                  With the protection of tests around the existing code, redesign it to improve its
                  quality.
                </li>
                <li>
                  Write new functional/integration/unit tests for the new functionality that is to
                  be introduced.
                </li>
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <q>Write tests until fear is transformed into boredom</q>
          <p style="font-size: 0.5em">&mdash; Kent Beck</p>
        </section>
        <section id="where">
          <section>
            <h2 class="r-fit-text">Where?</h2>
            <aside class="notes">Where should these tests live?</aside>
          </section>
          <section>
            <h3>Close to the Source</h3>
            <p class="fragment">Keeping them close to the code helps:</p>
            <ul>
              <li class="fragment">Discoverability by developers.</li>
              <li class="fragment">Ensure they will be kept up to date.</li>
            </ul>
            <aside class="notes">
              In social psychology, the proximity principle suggests that people closer together in
              a physical environment are more likely to form a relationship than those farther away.
              <div style="font-size: small">
                [<a
                  href="https://www.verywellmind.com/what-is-the-proximity-principle-in-psychology-5195099"
                  >What Is the Proximity Principle in Psychology? (verywellmind.com)</a
                >]
              </div>
            </aside>
          </section>
        </section>
        <section>
          <q>I think when you hear the phrase "it's just test code". To me that's a code smell.</q>
          <p style="font-size: 0.5em">&mdash; Alan Page</p>
        </section>
      </div>
    </div>
    <script type="module" src="reveal.js"></script>
  </body>
</html>
